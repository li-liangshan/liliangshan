#!/usr/bin/env bash

# 1）什么是Redis？
# Redis是一个开源的高级键值数据存储和缓存。它也被称为数据结构服务器，其键不仅包含字符串，还包含哈希，集合，列表和有序集。

# 2）Redis是什么意思？
# Redis代表Remote Dictionary Server。

# 3）Redis与其他数据库有何不同？
# Redis是一个NoSQL，Opensource，内存数据结构存储。它遵循键值存储的原则。
# 它非常快速，持久，可移植，支持多种语言，如C，C ++，C＃，Clojure，Common Lisp，D，Dart，Erlang，Go，Haskell，Haxe，Io，Java，
# JavaScript（Node.js），Julia， Lua，Objective-C，Perl，PHP，纯数据，Python，R，球拍，Ruby，Rust，Scala，Smalltalk和Tcl。

# 4）Redis用哪种语言编写？
# Redis是用ANSI C编写的，主要用于缓存解决方案和会话管理。它为商店值创建唯一键。

# 5）Redis的用途是什么？
# Redis是一个特殊的键值存储数据库，可以用作NoSQL数据库或内存缓存存储，以在提供存储在系统内存中的数据时提高性能。

# 6）如何与Redis互动？
# 安装服务器后，您可以运行redis安装提供的Redis客户端，也可以打开命令提示符并使用以下命令：

# redis-cli
# 通过使用其中任何一个，您可以与Redis交互。

# 7）哪些是最受欢迎的Redis公司？
# Twitter，Github，Stackoverflow等是使用Redis的最受欢迎的公司。

# 8）Redis的主要特点是什么？
# 以下是Redis的主要功能：

# Redis安装和管理非常简单。
# Redis非常快。它每秒可以执行100000个查询。
# Redis速度很快，因为数据在内存中持久存储并存储在磁盘上。
# Redis非常快，因为它将整个数据集加载到主存储器中。
# 处理不同数据类型的Redis操作是原子操作，因此可以安全地完成这些操作，即设置或增加密钥，添加或删除集合中的元素或增加计数器。
# 它支持各种类型的数据结构，如字符串，散列，集合，列表，排序集等。
# Redis支持多种语言，如C，C ++，C＃，Ruby，Python，Twisted Python，PHP，Erlang，Tcl，Perl，Lua，Java，Scala等。
# 如果您不喜欢您喜欢的语言，您可以编写自己的客户端库，因为协议非常简单。
# Redis支持简单的主从复制。
# Redis是便携式的。
# 有关更多信息：请单击此处

# 9）解释Redis的复制功能？
# 复制对于在大数据系统中存档高级别可用性非常重要。需要在n个地方复制数据。这遵循主从方法，其中主副本由主从维护并且复制到n个其他节点。

# 10）使用Redis有什么好处？
# 以下列出了Redis的一些重要优势：
# Redis非常快。
# 它支持服务器端锁定。
# 它有一个丰富的客户端库。
# 这是一个很好的反击。
# 它支持原子操作。

# 11）使用Redis有哪些缺点/限制？
# 以下是Redis的缺点/限制：
# 它是单线程的。
# 它对一致哈希的客户端支持有限。
# 它具有很大的持久性开销。
# 它没有广泛部署。

# 12）Redis和RDBMS有什么区别？
# Redis和RDBMS之间存在很多差异：
# Redis是NoSQL数据库，而RDBMS是SQL数据库。
# Redis遵循键值结构，而RDBMS遵循表结构。
# Redis非常快，而RDBMS相对较慢。
# Redis将所有数据集存储在主存储器中，而RDBMS将其数据集存储在辅助存储器中。
# Redis通常用于存储小型和常用文件，而RDBMS用于存储大文件。
# Redis仅为Linux，BSD，Mac OS X，Solaris提供官方支持。它目前没有为Windows提供官方支持，而RDBMS提供对两者的支持。
# 有关更多信息：请单击此处

# 13) 为什么Redis不同于其他的键值存储数据库？
# 有两个主要原因：
# Redis发展方向不同与其他键值数据库，它能包含很多复杂数据类型，对这些数据类型操作都是原子的。Redis数据类型与基本数据结构强相关，直接暴露给
# 程序员，没有增加抽象层。
# Redis是一个内存数据库，而不是持久化在硬盘数据库中，因此为了实现高速读写，数据集大小不能超过内存。内存数据库另一个优点是，内存数据库相对于
# 硬盘数据库非常容易操作复杂数据结构，因此Redis的可以做很多事情，很少有内部的复杂性。与此同时两款磁盘存储格式（RDB和AOF）不需要支持随机访
# 问，因此他们是紧凑的，而且总是以追加形式生成（甚至AOF日志轮换也是一个追加操作，因为新版本是由内存中的副本生成）。

# 14) Redis内存使用情况？
# 举几个例子（所有数据基于64位实例）
# 一个空实例大约占用1M内存
# 1百万简单字符串键值对大约占用100M内存
# 1百万哈希表键值对，每个对象有5个属性，大约占用200M内存
# 为了测试你的用例，使用redis-benchmark工具生成随机数据集，使用INFO memory命令检查使用内存空间。
# 存储相同的键，64位系统比32位系统使用更多的内存，键值很小情况下更明显。这是因为64位系统指针占用8字节。但是64位系统优点是可以配置更多内
# 存（校对注：32位操作系统支持的内存最多为2的32次方，就是4G），因此为了运行大型Redis服务器，64位系统或多或少都是需要的。另一种方案是使用分片。

# 15) 我喜欢Redis的高性能操作和特性，但是不喜欢所有内容都在内存中，我不能创建一个比内存更大数据集。有计划改变吗？
# 过去为了允许数据集超过RAM大小，Redis开发人员尝试使用虚拟内存和其他系统，但是我们非常高兴可以把一件事情做好：数据服务由内存提供，磁盘用于
# 存储数据。所以现在没有计划为Redis创建磁盘后端，毕竟Redis大部分特性都是基于其当前架构设计的。
# 你的真正问题并不是所需的总内存，而是你需要划分你的数据集到多个Redis实例上，为了获取更多信息请阅读本文档中的分区页面。

# 16) 同时使用Redis和磁盘数据库，是不是一个好想法？
# 是的，一个通用的设计方案是，在非常频繁的写小的数据时采用Redis（并且你需要使用Redis数据结构给你的问题建立高效模型），以及将大数据存储到
# SQL数据库或者最终一致性磁盘数据库中。

# 17) 有没有方法降低Redis内存使用率？
# 如果可以的话使用Redis 32位实例。另外，还要善于使用哈希表，列表，有序集合和整数集，因为在特殊情况下Redis使用这些数据类型可以更紧凑存储
# 一些元素。可以在内存优化页面获取更多信息。

# 18) Redis内存不足时会发生什么？
# Redis要么被Linux内核OOM杀掉，抛出错误崩溃，要么开始变得卡顿。随着现代操作系统malloc方法通常都不返回NULL，而是服务器开始交换，因此
# Redis性能降低，因此你可能会观察到一些错误现象。
# INFO命令返回Redis使用内存总量，因此你可以编写脚本监控Redis服务器内存临界值。
# Redis内置保护措施允许用户在配置文件中使用maxmemory选项，设置Redis最大占用内存。如果达到此限制，Redis将开始返回错误给写命令（但是
# 将继续接受只读命令），或者当最大内存限制达到时也可以配置为驱逐键，在这种情况下Redis作为缓存使用。
# 我们有文档描述Redis作为LRU缓存使用。

# 19) 在Linux系统中，即使我有很多空闲内存，后台保存失败报fork错误！
# 精辟答案：echo 1 > /proc/sys/vm/overcommit_memory 🙂
# 详细回答：
# Redis后台保存模式依赖现代操作系统的写时拷贝技术。Redis fork（创建一个子进程）是父进程精确拷贝。子进程存储数据到磁盘并且最终退出。从理论
# 上讲，子进程应该和父进程使用同样多内存，作为父进程副本，但是得益于多数现代操作系统实现的写时复制技术，父进程和子进程共享内存页。内存页在
# 父进程或子进程改变时将被复制。当子进程保存时，理论上所有页面都可能改变，Linux无法提前告知子进程需要多少内存，因此如果overcommit_memory
# 设置为0，fork将会失败除非有足够的空闲RAM真正复制父进程内存页.结果是，如果你有3G Redis数据集，只有2G可用内存将会失败。
# overcommit_memory设置为1，意味着Linux 使用更乐观方式fork，这确实是你所期望的Redis。
# “理解虚拟机内存 （校对注：有兴趣可以翻译此文在并发网发表）”是红帽经典文章，可以了解Linux虚拟内存怎么工作，overcommit_memory和
# overcommit_ratio的替代品。这篇文章校正了proc(5)用户手册对overcommit_memory1和2配置正确含义。

# 20) Redis磁盘快照是不是原子操作？
# 是的，当服务器不在执行命令时，Redis后台保存进程总是被创建，因此每个命令在RAM中是原子的，并且在磁盘快照过程也是原子的。

# 21) Redis是单线程的，我怎么利用多CPU/核?
# CPU基本不可能成为的Redis的瓶颈，因为通常Redis受限于内存或网络。例如使用Pipelining，Redis运行在普通的Linux系统上，每秒可以处理50万
# 请求，所以如果你的应用程序主要使用O(N) 或者 O(log(N))命令，几乎不会使用太多的CPU。
# 然而为了最大限度利用CPU，你可以在一台机器上启动多个Redis实例，并把它们设置为不同服务器。某些时候单个机器是不够的，所以如果你想使用
# 多个CPU，你可以提前考虑使用分片。
# 关于使用多Redis实例，你可以在Partitioning page找到更多的信息

# 22) 单个Redis实例最多可以存储多少键？哈希表、列表、集合和有序集合最大可以包含多少元素？
# Redis最大可以处理2^32键，实践测试每个实例最少可以处理2.5亿键。
# 每个哈希表、列表、集合和有序集合可以容纳2^32元素。
# 换句话说，Redis极限容量就是系统可用内存。

# 23) 为什么我的从实例与主实例拥有不同数量键？
# 如果你使用有生存周期的键，这就是正常现象。这就导致主从实例键的数量不一致原因。
# 主实例在第一次与从实例同步时生成RDB文件。
# RDB文件不包含已经过期的键，但是已经过期的键仍然在内存中。
# 尽管这些键从逻辑上说已经过期失效，但是还在Redis主实例内存中，他们并不被识别为存在的，当增量或访问这些键时这些键会被回收。尽管从逻辑上说
# 这些键不是数据集一部分，但是INFO和DBSIZE命令结果包含这些信息。
# 当从实例读取主实例生成的RDB文件时，过期键不会被载入。
# 为很多键设置过期属性，通常为用户提供了在从实例上存储更少键，但是实际上实例内容没有逻辑区别。
